
### int 和 uint
* 而 int 和 uint 是针对目标设备优化的类型:
    * 在树莓派 2、比较老的移动设备上，int 和 uint 都是 32 位的。
    * 在比较新的计算机上，int 和 uint 都是 64 位的
* Tip:
    * 如果你在较老的 32 位设备上，使用了超过 20 亿的整数，并且代码还能运行那么最好使用 int64 和 uint 64 来代替 int 和 uint
* 虽然在某些设备上 int 可以看作是 int32，在某些设备上 int 可以看作是 int64，但它们其实是 3 种不同的类型
* int 并不是其它类型的别名

### 打印数据类型
* 在 Printf 里使用 %T 就可以打印出数据的类型

### uint8
* uint8 可以用来表示 8 位的颜色 (红绿蓝: 0-255)
~~~
var red, green, blue uint8 = 0，141, 213
~~~
* 为什么不使用 int ?
    * uint 8 的取值范围正好合适，而 int 则多出来几十亿不合理的数。
    * 如果很多颜色数据连续存储，例如未被压缩的图片，那么使用uint8 可以节省很多内存。

### 十六进制表示法
* Go 语言里，在数前面加上 0x 前缀，就可以用十六进制的形式来表示数值。
~~~
var red ,green, blue uint8 = 0，141，213
var red, green, blue uint8 = 0x00，0x8d. 0xd5
~~~

### 整数环绕
* 所有的整数类型都有一个取值范围，超出这个范围，就会发生“环绕”

### 打印每个 bit
* 使用 %b 格式化动词
~~~
var green uint8 = 3
fmt.Printf("%08b\n",green )
green+
fmt.Printf("%08b\n",green )
~~~

### 整数类型的最大、最小值
* math 包里，为与架构无关的整数类型，定义了最大、最小值常量：
~~~
math.MaxInt16
math.MinInt64
~~~
* 而 int 和 uint，可能是 32 或 64 位的。

### 如何避免时间发生环绕
* Unix 系统里，时间是以 1970 年 1 月1 日至今的秒数来表示的。
* 但是在 2038 年，这个数就会超过 20 多亿，也就是超过了 int32 的范围。
* 应使用: int64 或 uint64