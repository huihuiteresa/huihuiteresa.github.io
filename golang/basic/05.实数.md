### 声明浮点型变量
* 下面这三个语句的效果是一样的:
    ~~~
    days := 365.2425
    var days = 365.2425
    var days float64 = 365.2425
    ~~~
* 只要数字含有小数部分，那么它的类型就是 float64
* 如果你使用一个整数来初始化某个变量，那么你必须指定它的类型为float64，否则它就是一个整数类型:
    ~~~
    var days float64 = 42
    ~~~

### 单精度浮点数类型
* Go 语言里有两种浮点数类型:默认是 float64
    * 64 位的浮点类型
    * 占用 8 字节内存
    * 某些编程语言把这种类型叫做 double (双精度)
* float32
    * 占用 4 字节内存
    * 精度比 float64 低
    * 有时叫做单精度类型
* 想要使用单精度类型，你必须在声明变量的时候指定该类型
~~~
var pi64 = math.Pi
var pi32 float32 = math.Pi
~~~

### 单双精度的使用场景
* 当处理大量数据时，例如 3D 游戏中的数千个顶点，使用 float32 牺牲精度来节省内存是很有意义的。
* math 包里面的函数操作的都是 float64 类型，所以应该首选使用float64，除非你有足够的理由不去使用它。

### 零值
* Go 里面每个类型都有一个默认值，它称作零值
* 当你声明变量却不对它进行初始化的时候，它的值就是零值。
~~~
var price float64
fmt.Println(price)
~~~

### 显示浮点类型
* 使用 Print 或 Println 打印浮点类型的时候，默认的行为是尽可能的多显示几位小数
* 如果你不想这样，那么你应该使用 Printf 函数，结合 %f 格式化动词来指定显示小数的位数:
~~~
func main() {
	third := 1.0 / 3
	fmt.Println(third)
	fmt.Printf("%v\n", third)
	fmt.Printf("%f\n", third)
	fmt.Printf("%.3f\n", third)
	fmt.Printf("%4.2f\n", third)
}
~~~

### %f格式化动词
* 它由两部分组成
* 宽度:会显示出的最少字符个数 (包含小数点和小数 )
    * 如果宽度大于数字的个数，那么左边会填充空格
    * 如果没指定宽度，那么就按实际的位数进行显示
* 精度: 小数点后边显示的位数
* 如果想使用 0 代替空格作为填充:
~~~
fmt.Printf("%05.2fn", third)
~~~

### 浮点类型的精度
* 可以看到，浮点类型不适合用于金融类计算
* 为了尽量最小化舍入错误，建议先做乘法，再做除法

### 如何比较浮点类型
~~~
piggyBank := 0.1
piggyBank += 0.2
fmt.Printin(piggyBank == 0.3)
fmt.Printin(math.Abs(piggyBank-0.3) < 0.0001)
~~~