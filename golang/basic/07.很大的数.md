### 数太大了怎办?
* 浮点类型可以存储非常大的数值，但是精度不高
* 整型很精确，但是取值范围有限。
* 如果你需要很大的数，而且要求很精确，那么怎么办
    * int64 可以容纳很大的数，如果还不行，那么:
    * uint64 可以容纳更大的正数，如果还不行，那么:
    * 也可以凑合用浮点类型，但是还有另外一种方法:
* 使用 big 包。

### big 包
* 对于较大的整数 (超过10的18次方 ) : big.Int
* 对于任意精度的浮点类型，big.Float
* 对于分数，big.Rat

### big.lnt
* 一旦使用了 big.int，那么等式里其它的部分也必须使用 big
* IntNewInt() 函数可以把 int64 转化为 big.Int 类型
* 如何把 24 x 10^18 转化为 big.int 类型?
    * 首先 new 一个 big.Int·
    * 再通过 Setstring 函数把数值的字符串形式，和几进制传递进行即可。
* 缺点: 用起来繁琐，且速度慢

### 较大数值的常量
* 在 Go 里面，可以为常量指明类型 (这句话会报错) :
    ```
    const distance uint64 = 24000990000900990000
    ```
* 也可以不指明常量的类型。
* 对于变量，Go 会使用类型推断;
* 而在 Go 里面，常量是可以无类型的 (untyped) ，这句话就不会报错:
    ```
    const distance = 24990999900909909999
    ```
* 常量使用 const 关键字来声明，程序里的每个字面值都是常量。
* 这意味着:比较大的数值可以直接使用 (作为字面值)
* 针对字面值和常量的计算是在编译阶段完成的
* Go 的编译器是用 Go 编写的，这种无类型的数值字面值就是由 big包所支持的。这使你可以操作很大的数(超过18的10^18)
* 只要能够容纳得下，那么常量就可以赋值给变量。
* 尽管 Go 编译器使用 big 包来处理无类型的数值常量，但是常量和big.Int 的值是不能互换的。