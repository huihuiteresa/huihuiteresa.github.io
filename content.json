[{"title":"SQLServer行转列","date":"2020-07-01T13:24:20.000Z","path":"SqlServer/rowtocolumn/","text":"建表，添加测试数据12345678910111213141516--删除临时表if object_id(&#39;tempdb..#demo&#39;) is not null drop table #tempCREATE TABLE #demo( row1 NVARCHAR(10), row2 NVARCHAR(10), col NVARCHAR(10), colval NVARCHAR(10));INSERT INTO #demo (row1,row2,col,colval)VALUES( N&#39;huihui&#39;, N&#39;1&#39;,N&#39;语文&#39;, N&#39;1&#39; );INSERT INTO #demo (row1,row2,col,colval)VALUES( N&#39;huihui&#39;, N&#39;1&#39;,N&#39;数学&#39;, N&#39;2&#39; );INSERT INTO #demo (row1,row2,col,colval)VALUES( N&#39;huihui&#39;, N&#39;1&#39;,N&#39;英语&#39;, N&#39;3&#39; );INSERT INTO #demo (row1,row2,col,colval)VALUES( N&#39;huihui&#39;, N&#39;2&#39;,N&#39;英语&#39;, N&#39;3&#39; );INSERT INTO #demo (row1,row2,col,colval)VALUES( N&#39;haha&#39;, N&#39;2&#39;,N&#39;英语&#39;, N&#39;3&#39; ); 行转列sql123456789101112--sqldeclare @col varchar(3000)&#x3D;&#39;&#39;, @selCol VARCHAR(3000)&#x3D;&#39;&#39;,@sql varchar(3000)&#x3D;&#39;&#39;;select @col&#x3D;@col+&#39;,[&#39;+[col]+&#39;]&#39; from (select distinct [col] from #demo) a order by [col];select @selCol&#x3D;@selCol+&#39;,max([&#39;+[col]+&#39;]) as &#39;+&#39;[&#39;+[col]+&#39;]&#39; from (select distinct [col] from #demo) a order by [col];select @col&#x3D;right(@col,len(@col)-1);select @selCol&#x3D;right(@selCol,len(@selCol)-1);set @sql&#x3D;&#39;select row1,row2,&#39;+@selCol+&#39; from( select row1,row2,&#39;+@col +&#39;from #demo a pivot (max(colval) for col in(&#39;+@col+&#39;) ) as pv ) b group by row1,row2&#39;;exec(@sql); 说明需要分组情况，网上找的大部分都是不带group by的，记录下。","tags":[{"name":"行转列","slug":"行转列","permalink":"https://huihuiteresa.github.io/tags/%E8%A1%8C%E8%BD%AC%E5%88%97/"}]},{"title":"设计模式原则","date":"2020-06-22T00:23:16.000Z","path":"designpatterns/principle/","text":"架构中的设计原则单一职责原则：系统中的每一个对象都应该只有一个单独的职责，而所有对象所关注的就是自身职责的完成。 里氏替换原则：在任何父类出现的地方都可以用它的子类来替换。 子类必须完全实现父类的方法 子类可以有自己的特性 覆盖或者实现父类的方法时输入参数可以被放大 覆写或者实现父类的方法时输出结果可以被缩小。 依赖注入原则（依赖反转原则）：要依赖于抽象，不要依赖于具体的实现。 三点说明： 高层模块不应该依赖低层模块，两者都应该依赖于抽象（抽象类或接口） 抽象（抽象类或接口）不应该依赖于细节（具体实现类） 细节（具体实现类）应该依赖抽象 实现方式： 通过构造函数传递依赖对象 通过setter方法传递依赖对象 接口声明实现依赖对象 接口分离原则：不应该强迫客户程序依赖它们不需要使用的方法。 迪米特原则：一个对象应当对其他对象尽可能少的了解。 开闭原则：一个对象对扩展开放，对修改关闭。 合成复用原则：尽量使用合成/聚合的方式，而不是使用继承。 接口 接口的思想就是“封装隔离” 接口与抽象类的选择 优先使用接口； 在既要定义子类行为，又要为子类提供公共的功能时应选择抽象类；","tags":[{"name":"设计模式原则","slug":"设计模式原则","permalink":"https://huihuiteresa.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/"},{"name":"设计模式","slug":"设计模式","permalink":"https://huihuiteresa.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}]